//
// Created by Damian Netter on 12/05/2025.
//

#include "../include/ZNBKit/vm/vm_management.hpp"

#include "../../shared/include/ZNBKit/debug.hpp"

std::unique_ptr<znb_kit::vm_object> znb_kit::vm_management::create_and_wrap_vm(const std::string &classpath)
{
    vm_data vm_data;
    vm_data.version = JNI_VERSION_1_8;
    vm_data.classpath = classpath;

    jvmti_data jvmti_data;
    jvmti_data.version = JVMTI_VERSION;

    jvmti_data.capabilities.can_get_bytecodes = true;

    return create_and_wrap_vm(vm_data, jvmti_data);
}

std::unique_ptr<znb_kit::vm_object> znb_kit::vm_management::create_and_wrap_vm(const vm_data &vm_data,
                                                             const std::optional<jvmti_data> jvmti_data)
{
    debug_print_ignore_formatting("[VM] Initializing Java Virtual Machine..."); //messages generated by AI, cuz i ain't writing them myself
    const auto [jvm, jni] = create_vm(vm_data);

    jvmtiEnv *jvmti = nullptr;
    debug_print_ignore_formatting("[VM] ═══════════════════════════════════");

    if (jvmti_data.has_value())
    {
        jvmti = get_jvmti(jvm, jvmti_data.value());
        debug_print_ignore_formatting("[VM] JVMTI initialization requested registered.");
    }
    else
    {
        debug_print_ignore_formatting("[VM] JVMTI initialization omitted - optional features unavailable");
    }

    debug_print_ignore_formatting("[VM] Java Virtual Machine initialization complete");

    return std::make_unique<vm_object>(vm_data.version, jvm, jvmti, jni);
}

std::unique_ptr<znb_kit::vm_object> znb_kit::vm_management::wrap_vm(JavaVM *jvm, const std::optional<jvmti_data> jvmti_data)
{
    debug_print_ignore_formatting("[VM] Wrapping existing Java Virtual Machine...");

    if (jvm == nullptr)
    {
        throw std::invalid_argument("JavaVM is null.");
    }

    JNIEnv *jni = nullptr;
    if (jvm->GetEnv(reinterpret_cast<void **>(&jni), JNI_VERSION_1_8) != JNI_OK)
    {
        throw std::runtime_error("Failed to get JNIEnv from JavaVM.");
    }

    jvmtiEnv *jvmti = nullptr;
    if (jvmti_data.has_value())
    {
        jvmti = get_jvmti(jvm, jvmti_data.value());
    }

    return std::make_unique<vm_object>(JNI_VERSION_1_8, jvm, jvmti, jni);
}

void znb_kit::vm_management::cleanup_vm(JavaVM *vm)
{
    wrapper::check_for_corruption();

    if (vm) {
        vm->DestroyJavaVM();
    }
}

jvmtiCapabilities znb_kit::vm_management::get_capabilities(const jvmtiEnv *jvmti, const jvmti_data data)
{
    if (jvmti == nullptr)
    {
        throw std::invalid_argument("JVMTI is null.");
    }

    jvmtiCapabilities capabilities = {};
    capabilities.can_get_bytecodes = data.capabilities.can_get_bytecodes;
    capabilities.can_generate_all_class_hook_events = data.capabilities.can_get_bytecodes;

    return capabilities;
}

std::pair<JavaVM *, JNIEnv *> znb_kit::vm_management::create_vm(const vm_data &vm_data)
{
    const bool use_classpath = vm_data.classpath.has_value();
    const int options_count = use_classpath ? 1 : 0;

    JavaVM *jvm;
    JavaVMInitArgs vm_args;
    JavaVMOption options[options_count];

    std::string classpath_option;

    if (use_classpath)
    {
        debug_print_ignore_formatting("[VM] ═══════════════════════════════════");
        debug_print_ignore_formatting("[VM] Configuring classpath for file-based class loading");

        const auto classpath = vm_data.classpath.value();

        if (classpath.empty() || !std::filesystem::exists(classpath))
        {
            throw std::invalid_argument("Unable to determine classpath. [" + classpath + "]");
        }

        classpath_option = "-Djava.class.path=" + classpath;

        options[0].optionString = const_cast<char *>(classpath_option.c_str());

        debug_print_ignore_formatting("[VM] Classpath configured: " + classpath);
    }

    vm_args.version = vm_data.version;
    vm_args.nOptions = options_count;
    vm_args.options = options;

    vm_args.ignoreUnrecognized = JNI_FALSE;

    JNIEnv *jni;

    if (JNI_CreateJavaVM(&jvm, reinterpret_cast<void **>(&jni), &vm_args) != JNI_OK)
    {
        throw std::runtime_error("Failed to initialize vm.");
    }

    return std::make_pair(jvm, jni);
}

jvmtiEnv * znb_kit::vm_management::get_jvmti(JavaVM *vm, const int version)
{
    jvmtiEnv *jvmti = nullptr;
    if (vm->GetEnv(reinterpret_cast<void **>(&jvmti), version) != JNI_OK)
    {
        throw std::runtime_error("Failed to get jvmti.");
    }

    return jvmti;
}

jvmtiEnv * znb_kit::vm_management::get_jvmti(JavaVM *vm, const jvmti_data data)
{
    jvmtiEnv *jvmti = nullptr;

    const int version = data.version;
    const int major = version >> 16 & 0xFF;
    const int minor = version >> 8 & 0xFF;
    const int patch = version & 0xFF;

    const std::string version_str = std::to_string(major) + "." + std::to_string(minor) + "." + std::to_string(patch);

    debug_print_ignore_formatting("[VM] Requesting JVMTI environment (version: " + version_str + ")");

    jvmti = get_jvmti(vm, data.version);

    const auto capabilities = get_capabilities(jvmti, data);

    debug_print_ignore_formatting("[VM] Requesting JVMTI capabilities");

    if (jvmti->AddCapabilities(&capabilities) != JVMTI_ERROR_NONE)
    {
        throw std::runtime_error("Failed to add jvmti capabilities.");
    }

    debug_print_ignore_formatting("[VM] JVMTI capabilities successfully applied");
    debug_print_ignore_formatting("[VM] JVMTI environment successfully initialized");
    debug_print_ignore_formatting("[VM] ═══════════════════════════════════");

    return jvmti;
}
